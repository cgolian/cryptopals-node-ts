import {BigNumber} from "bignumber.js";
import {CryptoBigNumber} from "./utils";
import {initSimplifiedSRP, SimplifiedSRPFunctions} from "./challenge38";
import * as fs from "fs";

describe('Challenge 38', () => {
    let N: BigNumber;
    let generator: BigNumber;
    let srp: SimplifiedSRPFunctions;

    beforeEach(() => {
        N = new CryptoBigNumber(`0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff`, 16);
        generator = new CryptoBigNumber(2);
        srp = initSimplifiedSRP(generator, N);
    });

    describe('valid password', () => {
        it('should compute the same session key for server/client', () => {
            // Client
            const salt = new CryptoBigNumber(111548975465456);
            const privateKey = srp.computePrivateKey(salt, 'trustno1');
            const passwordVerifier = srp.computePasswordVerifier(privateKey);
            // Client -> Server
            const clientKeys = srp.generateEphemeralKeysClient();
            // Server -> Client
            const serverKeys = srp.generateEphemeralKeysServer();
            const scramblingParameter = srp.computeScramblingParameter();
            // Client
            const sessionKeyClient = srp.computeSessionKeyClient(
                serverKeys.publicKey, clientKeys.privateKey, scramblingParameter, privateKey
            );
            // Server
            const sessionKeyServer = srp.computeSessionKeyServer(
                clientKeys.publicKey, serverKeys.privateKey, passwordVerifier, scramblingParameter
            );
            expect(sessionKeyClient).toEqual(sessionKeyServer);
        });
    });

    describe('MITM attack', () => {
        xit('should crack the password', () => {
            const salt = new CryptoBigNumber(1454875434567894635);
            const db: {
                [username: string]: {
                    passwordVerifier: BigNumber;
                    salt: BigNumber;
                };
            } = {};

            // Mock "registration" on client
            const email = 'a@example.com';
            const password = 'Abelard';
            // Mock "registration" server
            const privateKey = srp.computePrivateKey(salt, password);
            const passwordVerifier = srp.computePasswordVerifier(privateKey);
            db[email] = { passwordVerifier, salt };

            // Mock "challenge" request
            const clientKeys = srp.generateEphemeralKeysClient();
            // Mock "challenge" response
            const serverKeys = srp.generateEphemeralKeysServer();
            const scramblingParameter = srp.computeScramblingParameter();

            // Mock "authenticate" request
            const sessionKeyClient = srp.computeSessionKeyClient(
                serverKeys.publicKey,
                clientKeys.privateKey,
                scramblingParameter,
                privateKey
            );
            const sessionKeyDigest = srp.computeSessionKeyHMAC(sessionKeyClient, salt);
            // dictionary attack
            const wordsContent = fs.readFileSync('./src/set5/words.txt', 'utf8');
            const words: string[] = wordsContent.split("\n");
            let crackedPassword;
            for (let word of words) {
                word = word.trim();
                const potentialPrivateKey = srp.computePrivateKey(salt, word.trim());
                const potentialPasswordVerifier = srp.computePasswordVerifier(potentialPrivateKey);
                const computedSessionKey = srp.computeSessionKeyServer(
                    // was sent by client
                    clientKeys.publicKey,
                    // was computed by MITM
                    serverKeys.privateKey,
                    // is computed above
                    potentialPasswordVerifier,
                    // was generated by MITM
                    scramblingParameter
                );
                const computedSessionDigest = srp.computeSessionKeyHMAC(computedSessionKey, salt);
                if (sessionKeyDigest === computedSessionDigest) {
                    crackedPassword = word;
                    break;
                }
            }
            expect(password).toEqual(crackedPassword);
        });
    });
});